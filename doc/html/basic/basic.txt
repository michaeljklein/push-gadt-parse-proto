-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on Github at
--   <a>https://github.com/githubuser/basic#readme</a>
@package basic
@version 0.1.0.0

module Data.Range
class (Eq a, Show a, Monoid a, Arbitrary a) => ARanges a where {
    type family RElem a :: *;
}
fromListR :: ARanges a => [RElem a] -> a
fromListRN :: ARanges a => Int -> [RElem a] -> a
toListR :: ARanges a => a -> [RElem a]
insertR :: ARanges a => RElem a -> a -> a
deleteR :: ARanges a => RElem a -> a -> a
elemR :: ARanges a => RElem a -> a -> Bool
insertRange :: ARanges a => Range (RElem a) -> a -> a
deleteRange :: ARanges a => Range (RElem a) -> a -> a

-- | Range of values, equivalent to <tt>[a..b]</tt> with cases for
--   <tt>[]</tt>, <tt>[a..a]</tt>, and <tt>[a..a+b]</tt>
data Range a
EmptyRange :: Range a
Range :: a -> Range a
[fromRange] :: Range a -> a
Range2 :: a -> a -> Range a
[fromRangeMin] :: Range a -> a
[fromRangeMax] :: Range a -> a

-- | Minimum of a <a>Range</a>
minRange :: Range a -> Maybe a

-- | Maximum of a <a>Range</a>
maxRange :: Range a -> Maybe a

-- | Left-fold over the <a>Range</a>, using the type's <a>Enum</a> instance
--   to provide values between the endpoints
foldRange :: Enum a => (a -> b -> b) -> b -> Range a -> b

-- | Pretty-print a <a>Range</a> using the given method to <a>show</a> the
--   endpoints
ppRangeWith :: (a -> String) -> Range a -> String
instance GHC.Base.Functor Data.Range.Range
instance GHC.Show.Show a => GHC.Show.Show (Data.Range.Range a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Range.Range a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Range.Range a)
instance (Test.QuickCheck.Arbitrary.Arbitrary a, GHC.Classes.Ord a, GHC.Num.Num a, GHC.Enum.Enum a, GHC.Show.Show a) => Data.Range.ARanges (Data.Range.Range a)
instance GHC.Base.Applicative Data.Range.Range
instance GHC.Classes.Ord a => GHC.Base.Monoid (Data.Range.Range a)
instance GHC.Classes.Ord a => Data.Semigroup.Semigroup (Data.Range.Range a)
instance Data.Bits.Bits a => Data.Bits.Bits (Data.Range.Range a)
instance Data.Bits.FiniteBits a => Data.Bits.FiniteBits (Data.Range.Range a)
instance (Test.QuickCheck.Arbitrary.Arbitrary a, GHC.Num.Num a) => Test.QuickCheck.Arbitrary.Arbitrary (Data.Range.Range a)

module Data.Attoparsec.Utils

-- | Get the <a>State</a> of a <a>Parser</a>
parserState :: Parser i (State i)

-- | Always succeeds
parserPos :: Parser i Pos

-- | Parse with the range of <a>Pos</a>itions consumed.
--   
--   For example:
--   
--   <pre>
--   λ&gt; let someDecimals = parseRanged decimal <tt>sepBy</tt> skip (not . isDigit)
--   λ&gt; (fmap . first . ppRangeWith) (show . fromPos) <a>&lt;$&gt;</a> parseOnly someDecimals "10 20 30 "
--   Right [("[0..2]",10),("[3..5]",20),("[6..8]",30)]
--   </pre>
parseRanged :: Parser i a -> Parser i (Range Pos, a)

module Lib
data Range1 a
Range1 :: !a -> !a -> Range1 a
[range1Min] :: Range1 a -> !a
[range1Max] :: Range1 a -> !a
data Ranged1 i a
Ranged1 :: !(Range1 i) -> !a -> Ranged1 i a
[ranged1] :: Ranged1 i a -> !(Range1 i)
[ranged1Val] :: Ranged1 i a -> !a

-- | NOTE: These should be extended to utilize the fact that the resulting
--   data structure is alternating
class Functor f => Push2 f g
push2 :: Push2 f g => f (g a b) -> f (g (f a) (f b))
pver2 :: Push2 f g => f (f (g a b)) -> f (g (f a) (f b))
part2 :: Push2 f g => f (g a b) -> f (f (g a b))
pushP2 :: Push2 f Either => (a -> Bool) -> f a -> f (Either (f a) (f a))
class (Functor f, Functor g) => Push f g
push :: Push f g => f (g a) -> f (g (f a))
part :: Push f g => f (g a) -> f (f (g a))
pver :: Push f g => f (f (g a)) -> f (g (f a))

-- | <a>fmap</a> and <a>push</a>
pmap :: Push f g => (a -> g b) -> f a -> f (g (f b))

-- | <a>pmap</a> with a predicate
pmapP :: Push f Maybe => (a -> Bool) -> f a -> f (Maybe (f a))

-- | <a>fmap</a> and <a>push2</a>
pmap2 :: Push2 f g => (a -> g b c) -> f a -> f (g (f b) (f c))

-- | <a>pmap2</a> with a predicate
pmapP2 :: Push2 f Either => (a -> Bool) -> f a -> f (Either (f a) (f a))
instance GHC.Base.Functor (Lib.Ranged1 i)
instance (GHC.Show.Show a, GHC.Show.Show i) => GHC.Show.Show (Lib.Ranged1 i a)
instance (GHC.Classes.Ord a, GHC.Classes.Ord i) => GHC.Classes.Ord (Lib.Ranged1 i a)
instance (GHC.Classes.Eq a, GHC.Classes.Eq i) => GHC.Classes.Eq (Lib.Ranged1 i a)
instance GHC.Read.Read a => GHC.Read.Read (Lib.Range1 a)
instance GHC.Show.Show a => GHC.Show.Show (Lib.Range1 a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Lib.Range1 a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Lib.Range1 a)
instance Lib.Push (Control.Comonad.Cofree.Cofree GHC.Base.Maybe) GHC.Base.Maybe
instance Lib.Push2 (Control.Comonad.Cofree.Cofree GHC.Base.Maybe) Data.Either.Either
instance Control.Comonad.Comonad (Lib.Ranged1 i)
